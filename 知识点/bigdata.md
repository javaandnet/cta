# 基本知识
   1. マルチテナンシーおよびメタデータの概要
      1. 多租户：逻辑隔离
      2. メタデータ
   2. 检索架构
      1. 许多种地方都能使用
      2. 因为需要生成Index，更新的数据往往15分钟后才能被查询到
   3. 查询流程
      1. 在索引中搜索适合的记录
      2. アクセス権限、検索制限、およびその他の検索条件に基づいて結果を絞り込むこと，結果セットが作成されます。  
         1. 这种结果集一般包含最关联的数据
         2. 到达界限后，剩下的数据就不要了
      3. 利用此结果集，在数据库中查询数据 
   4. 検索には、SOSL でもアクセスできます。これは、API または Apex を使用して起動できます。
# 大数据系统系统架构
   1. 查询オプティマイザ（optimizer）最适化
      1. 効果的なクエリの作成
      2. 検索条件の選択度の判断（只取最必要的数据）
      3. SOQL の使用による検索条件の選択度の判断： 通过分组化查询个数来判断复杂度
         1. 一个条件例子：
            1. SELECT Id, Name FROM Opportunity WHERE Stagename = 'Closed Won'  
            2.  SELECT Stagename, COUNT(id) FROM Opportunity
          2.  多个条件例子
              1.  SELECT Id, Name FROM Opportunity WHERE Stagename = 'Closed Won' AND CloseDate = THIS_WEEK GROUP BY ROLLUP (Stagename)
              2.  SELECT WEEK_IN_YEAR(CloseDate), CALENDAR_YEAR(CloseDate), COUNT(id)  
                   FROM Opportunity　GROUP BY ROLLUP(WEEK_IN_YEAR(CloseDate),CALENDAR_YEAR(CloseDate))　ORDER　BY CALENDAR_YEAR(CloseDate), WEEK_IN_YEAR  (CloseDate)
               3. 解释
                  1. このクエリでは、すべての年のすべての週における CloseDate 別の商談レコードの分布に関する統計情報が返されます。
           3. セレクティブ（Selective）解释
              1. 検索条件で 2 つ以上の条件が (AND を使用して) 組み合わされており、条件の対象が以下のしきい値未満である場合、クエリオプティマイザは、検索条件全体をセレクティブと判断します。
                 1. 各条件の選択度しきい値の 2 倍
                 2. これらの項目の論理積の選択度しきい値
                 3. このトピックの 3 番目の例では、以下を意味します。  
                       Status = ‘Closed Won’ がセレクティブ (49,899 < 150,000)  
                       CloseDate = THIS_WEEK がセレクティブ (~3000 < 150,000)  
               2. 検索条件の 1 つがセレクティブでない場合、たとえば Status=’Closed Won’ が 250,000 レコードに対応している場合でも、2 つの可能性を満たせば、検索条件全体がセレクティブになることができます。
               3. OR 演算子を使用する場合は、各条件がしきい値に個々に一致する必要があります。
               4. 总结：当超过 20万条，必须采用セレクティブ。否则会出现「System.QueryException: Non-selective query against large object type (more than 200000 rows)」
                  1. 满足下列两个条件的语句被称为SOQLは「選択的（selective）」
                     1. WHERE句で用いられている項目のうち一つ以上がインデックス項目である
                     2. 当該のインデックス項目を用いたフィルタにより、レコードが特定の閾値を下回る数まで絞り込まれる
                   2. 判定方式：下列存在一个就行
                      1. WHERE句に用いられている項目がインデックス項目である
                      2. 索引没有下列情况
                         1. 項目の値が特定の閾値を超える
                         2. 演算子が否定演算子（NOT EQUAL TO, NOT CONTAINS, NOT STARTS WITHなど）
                         3. 検索条件にCONTAINSが用いられ、なおかつスキャン行数が333,333を超える
                         4. 空の値と比較している（ != ‘ ‘）
      4. 削除されたレコードが選択度に与える影響の理解
         1. 使用IsDeleted来判断
   2.  Database统计情报
       1.  现代数据库收集各种数据便于更好查询
       2.  Salesforce因为采用多租户，采用独自的统计方式。在大批量操作数据后，统计情报的过程每晚更新。
   3. Skinny Table
      1. 说明
         1. 对某些频繁操作的项目，为了避免结合建立スキニーテーブル。
         2. 与参照元数据同步更新
         3. 无法自己做成，Salesforceサポートにケースを起票することで作成でき
       2. 性能改善的理由
          1. スキニーテーブル内の項目のみを参照する参照のみの操作は追加結合が不要なため。
          2. 不包含逻辑删除的数据
          3. 注意如果没设计好的话，会造成负载过大，效率低下
        3. 可以在自定义对象以及客户、联系人、机会、潜在顾客和案例对象上创建瘦表。您可以提高报告、列表视图和 SOQL 的性能。 
        4. スキニーテーブルとスキニーインデックスには包含加密的数据。
        5. 例子：反复查询 01/01/11 ～ 12/31/11 数据的时候，使用スキニーテーブル的时候：Year 項目を表示して Year = '2011' で絞り込むことができます。
        6. 考慮事項
           1. 最大包含100列
           2. スキニーテーブルには、別のオブジェクトの項目を含めることができません。
           3. Full Sandbox の場合: スキニーテーブルは Full Sandbox 組織にコピーされます。（其他不行）
           4. 項目を追加したい場合、再度サポートへの連絡が必要
           5.  トランザクション数が多いオブジェクトに対してスキニーテーブルを有効化するとパフォーマンスが低下する。 基本的にスキニーテーブルの有効化は（大半のケースで）アンチパターンである。
   4. Index
      1. 一些概念
         1. 本番做成的，沙盒可以使用
         2. Salesforce 的多租户架构为不适合索引的自定义字段创建基础数据表。为了克服这一限制，平台创建数据的副本和包含有关数据类型的信息的索引表。
         3. 平台在此索引表上建立标准数据库索引。索引表对索引搜索可以有效返回的记录数设置了上限。
         4. 不包含Null
         5. **Salesforce是采用预查询的方式来进行判断的**
            1. 判断条数进行优化
      2.  几种类型
          1.  标准
              1.  Id
              2.  Name
              3.  Email：（※取引先責任者とリードのみ）
              4.  Foreign Key Relationships（参照関係と主従関係）
              5.  RecordTypeId
              6.  Division
              7.  CreatedDate
              8.  SystemModStamp (LastModifiedDate)
          2. 自定义
             1.  外部ID化した項目（外部IDは以下の項目にのみ設定可能）
                 1.  自動採番
                 2.  メール
                 3.  数値
                 4.  テキスト
             2.  ユニーク項目
                 1.  メール
                 2.  数値
                 3.  テキスト
             3.  インデックス付与のケース申請を行った項目
          3.  无法生成
              1.  複数選択リスト
              2.  ロングテキストエリア
              3.  リッチテキストエリア
              4.  **非決定性数式項目**
                  1.  直接、間接に他オブジェクトの項目
                  2.  常に同じ値を返すとは限らない関数 (TODAY や NOW など)
                  3.  所有者、自動採番、ディビジョン、監査項目 (CreatedDate および CreatedByID 項目は除く)
                  4.  インデックス付けできない項目(複数選択リストなど)
                  5.  特殊な機能を持つ標準項目
                      1.  商談: Amount、TotalOpportunityQuantity、ExpectedRevenue、IsClosed、IsWon
                      2.  ケース: ClosedDate、IsClosed
                      3.  商品: ProductFamily、IsActive、IsArchived
                      4.  ソリューション: Status
                      5.  リード: Status
                      6.  活動: Subject、TaskStatus、TaskPriority
              5.  暗号化されたテキスト
              6.  バイナリ項目
   5. 分区数据 将客户分成没有关系的小组
      1. 例：リード・取引先・カスタムオブジェクトとユーザはそれぞれ事前に定義したディビジョン（例：APAC・EMEA・AMER）に割り当てられる。
      2. 搜索范围可以指定
      3. 不好的地方
         1. 管理繁琐，增加コスト
         2. 変更が不可逆： ディビジョンを一度有効化すると、二度と元に戻せない
# 性能化最适方法
   1. マッシュアップの使用
      1. 两个系统互相结合 使用MashUp
      2. 下列几种方式
         1. 外部 Web サイト
            1. Salesforce UI に外部 Web サイトが表示され
         2. コールアウト：实时交换数据
      3. 有利点
         1. 数据不过期，最新化
         2. 两个系统进行统合，不需要独自的开发
      4. 不利点
         1. 访问数据花费信息
         2. 功能化缺失，比如说Report和FLow功能在外部没有
   2. 共有適用の延期： 因为共有Rule计算花费时间，可以延迟处理
   3. SOQL および SOSL の使用
      1. SOQL
         1. 実行対象：データベース
         2. Call：query()
         3. 1つObject、または関連性があるObject
         4. 項目確定
         5. 結果を並び替える
         6. 指定した条件を満たすレコード数を数える
      2. SOSL
         1. 実行対象：検索インデックス
         2. Call：search()
         3. データの保存先のオブジェクトまたは項目が不明であるため、最も効率的な方法で確認したい。
         4. 関連たは関連していない複数のオブジェクトおよび項目を効率的に取得する
         5. 分区数据使用的场合
      3. 注意点
         1. CONTAINS的场合，  SOSL比SOQL时间更快
         2. SOSL查找本质是把空格分隔的単語をトークン化でき、これを基に検索インデックスを構築する。当已经确认单语存在的场合，SOSL的速度更快，优先使用。
         3. 复数个Where检索条件存在的场合，Where里面加入Index的场合，不能使用Index的可能性也存在。这种情况下，能够把一个查询分成几个只使用一个Where条件的查询然后结合起来。
         4. 在使用选择List或者外部Key的场合，、null 値を使用する WHERE 検索条件でクエリを実行すると、インデックスは使用されないため、避けてください。
         5. 当可能传入Null作为检索条件的时候，可以首先判断，否则会一行一行来扫描
      4. カスタムクエリ検索
         1. 検索またはクエリ対象の項目数を最小限に抑えます。多数の項目を使用すると、多数の順列が発生し、調整が難しくなる場合があります
         2. SOQL、SOSL、または 2 つの組み合わせが検索に適切かどうかを判断します。
   4. 数据删除
      1. 数据删除的机制可能对大量数据的性能产生影响。删除的时候仅仅是软删除。
      2. 软删除的场合，删除的数据需要从查询里面排除。
      3. 数据物理删除的情况
         1. データをごみ箱に移動した 15 日後。
         2. ごみ箱がサイズ制限に達したとき。
         3. あるいは UI、API、Apex のいずれかを使用してごみ箱を空にする場合
         4. Bulk API および Bulk API 2.0 を使用する、跳过回收站，直接删除，大量数据删除的场合，可以使用Bulk API 2.0直接删除数据。
         5. カスタムオブジェクトの切り捨て機能を使用する、可以删除自定义对象的数据
# 建议
   1. Report   
      1.  确定分区，利用Object数尽量少
      2.  减少结合数
          1.  使用的Object
          2.  使用的关系
          3. 使用的场合可以数据非正规化，子Object不加集計，放在親Object
       3. 减少查询对象的记录数
          1. 未使用的记录可以アーカイブする、比如移动至カスタムオブジェクトテーブル。减少レポートオブジェクトのサイズ
          2. 使用标准的或是加入序列的项目作为查询条件
    2. API からのデータ読み込み
       1. 提高性能
          1. 2000件以上的数据推荐Bulk API 2.0 。使用Bulk フレームワーク，非同期的ワークフローの準備、実行、管理可以正常进行。
        2. 最有效率的操作使用
           1. 执行速度顺序：  insert() で、次に update()、upsert()。如果可能将upsert()分割成create() と update()。
           2. 使用Bulk API 2.0的时候，注意清洁数据，在Batch中发生错误的场合，这个Batch的单一行触发器会对性能造成巨大影响
        3. 传送的对象和处理的对象进行消减：更新得场合只对增量进行操作
        4. 送信时间和中断回数进行消减：
           1. カスタムインテグレーションの場合:不要以数据作为单位，読み込みごとに 1 回認証します。
           2. GZIP 圧縮と HTTP キープアライブを使用して、長時間にわたる保存操作中に接続が切断されるのを回避します。
        5.  避免计算：初次读取时就进行安全方面的相关设置，避免共享规则的重载
        6.  减少计算
            1.  初回読み込みで可能な場合は、共有ルールを入力する前にロールを入力します。
                1.  将用户设定到角色中
                2.  读取记录数据和所有者并触发角色层次结构的执行
                3.  设定PublicGroup和Queue，将计算结果转记
                4.  共有Rule一个一个追加，计算完了再加下一个
            2. PublicGroup和Queue做成和分配之前，首先追加用户和数据
               1. 新规ユーザと新規レコードデータ进行读取
               2. 作为必要，加载新規公開グループおよびキュー
               3. 共有Rule一个一个追加，计算完了再加下一个
            3. 计算延期处理，减少读取时间
               1. 首先将Apex的Trigger和WorkflowRule在读取时检证无效化，读取后关于Apex 一括処理进行调查
            4. 对Batch的size和Timeout可能性的平衡性进行调整
               1. SOAP API を使用するときには，为了避免TImeout，尽量设置比较大（200）
                  1. レコードが大きい。
                  2. 保存操作时伴随着不能延期的处理
            5.  Salesforce を使用するために Lightning Platform Web Service Connector (WSC) を最適化する：Axis などの Java API ではなく WSC を使用します。
            6.  親レコードのロック競合を最小限に抑える
                1.  先对親进行分组话。同じバッチ内で項目 ParentId 別にレコードをグループ化します。
            7. 共有適用を延期する：共有延后处理
            8. Salesforce へのデータ読み込みを避ける：目前是通过API
    3. API からのデータ抽出
       1. getUpdated() および getDeleted() の SOAP API を使用して、外部システムと Salesforce を 5 分を超える間隔で同期します。これより頻繁に同期する場合は、発信メッセージ機能を使用します。
       2. 100 万を超える結果が返される可能性があるクエリを使用するときには、Bulk API 2.0 のクエリ機能を使用することを検討してください。
    4. 检索
       1. 返すレコード数を削減する
       2. 結合数を削減する
       3. 効率を向上する
       4. 検索パフォーマンスを向上する
       5. 增加Index
    5.  SOQL と SOSL
        1.  複数の WHERE 条件を使用した SOQL クエリでインデックスを使用できない場合にインデックス付き検索を許可する
            1.  クエリを分解します。WHERE 句で OR で結合した 2 つのインデックス付き項目超过临界点：分成多个子查询然后结合
            2.  リアルタイムで計算される数式項目のクエリの実行を避ける
    6.  数据删除
        1.  大量のデータを削除する
        2.  データ削除プロセスの効率を向上する
            1.  当多个子数据删除的情况下，优先删除子数据
    7.  一般情报
        1.  共有計算を避ける：不要让一个用户拥有10000条以上数据
        2.  パフォーマンスの向上：使用跨多个对象分布数据的数据分层方法按需从另一个对象或外部存储获取数据。
        3.  大量のデータを使用する本番 Sandbox のフルコピーの作成にかかる時間を短縮する：项目履历尽量不要
        4.  リリースの効率を向上する：不要让一个用户拥有10000条以上数据，给一个取引先责任者分配数据
# 实例分析
   1. データ集計
      1. 客户希望使用标准报告汇总每月和每年的指标。客户每月和每年的详细信息存储在分别包含 400 万和 900 万条记录的自定义对象中。该报告正在聚合这两个对象的数百万条记录，因此性能并不是最佳的。
      2. 将每年每月的值保存成必要的形式
   2. **カスタム検索機能**
      1. 客户需要使用特定值和通配符在多个对象的大量数据中进行搜索。因此，客户创建了一个自定义 Visualforce 页面，允许用户输入 1 到 20 个不同字段，并使用 SOQL 对这些字段的任意组合执行搜索。（自定义查询）
         1. 当输入大量值时，WHERE 子句会变得很大并且难以调整。使用通配符时查询处理时间会增加。
         2. 您可能需要跨多个对象进行查询才能返回整个搜索查询的结果。这种方法会产生多个查询，从而扩大了搜索范围。
         3. SOQL 不一定适合所有查询类型。
      2. 解决方案
         1. 分析必须项目，减少检索项目个数，根据尽量使用Index的前提来确定一次检索的语句
         2. 复数Object的数据向单一Object非正规化，从而避免复数查询
         3. 各种语句生成需要注意，避免模糊检索。
   3. 客户希望能够允许项目中存在空值并对其进行查询。选择列表和外键字段上的单列索引会排除索引列为空的行，因此该索引不能用于空查询。
      1. 使用Null以外值
      2. 创建数式項目，加入Index
         1. Status_Value__c = IF(ISBLANK(Status__c), "blank", Status__c)
         2. SELECT Name FROM Object WHERE Status_Value__c = 'blank'
   4. 大量のデータを含む関連リストの表示
      1. 客户拥有数十万条帐户记录和 1500 万张发票，这些记录存储在与帐户具有主从关系的自定义对象中。由于发票相关列表的显示时间较长，导致每条账户记录的显示时间较长。
      2. 分析
         1. 牵扯数据倾斜，意指一条数据关联很多条子数据。Salesforce的限制是1万条。但实际没到这个限制就需要处理
         2. [関連リストの別途読み込みを有効化] 設定を使用することで、関連リストのクエリが完了するのを待つ間に取引先詳細が表示できるようになりました。
   5. API パフォーマンス
      1. 状況
         1. 顾客与外部系统结合
         2. 特定のオブジェクトのすべてのデータを対象に Salesforce でクエリを実行する
         3. 数据是从外部读取
         4. 什么数据需要删除是在インテグレーションプロセス中判断，Salesforceで再次查询从而获取全部Data的ID
         5. 该对象包含数百万条记录。此集成还使用共享层次结构中的特定 API 用户来限制检索的记录数量。查询在几分钟内完成。
         6. 在Salesforce中共享是一种强大的机制，但是在查询大量数据的时候，加入共享的时候会造成处理格外复杂。
      2. 解决方法
         1. 查询的时候赋予全部查询的权利。比如说系统管理员
         2. 只处理增量条件
   6. 查询排序最适化
      1. 查询查找最近 3 天内创建的所有记录，但对象中的数据量超过记录总数 30% 的标准索引阈值，最多可达 100 万条。查询性能很差。
      2. 解决办法
         1. SELECT Id,Product_Code__c FROM Customer_Product__c WHERE CreatedDate = Last_N_Days:3 ORDER BY CreatedDate LIMIT 99999
         2. 限制记录条数 99999
         3. 指定排序条件
   7. 複数結合レポートのパフォーマンス
      1. 客户使用四个相关对象创建了一个报表：帐户 (314,000)、销售订单 (769,000)、销售详细信息 (230 万) 和帐户类型 (120 万)。该报告没有太多的标准搜索，需要优化。
      2. 解决方法
         1. 加入多种检索条件
         2. 可能的情况下，减少Object的数据量
         3. 保证回收站的数据为空
         4. 保证不存在复杂的共享Rule
# 总结
   1.  Salesforce平台是一种维护性能平衡以及将原生程序和定制程序中放入大量数据的环境
   2.  两个原则
       1.  使用Slective 查询，加入适当的查询条件
       2.  有效的消减数据量，消减Salesforce内包含的数据
           1.  アーカイブ：压缩
           2.  マッシュアップ：放入其他系统
               1.  画面展示
               2.  数据联合
   3.  基本Salesforce 在查询时先做预查询，判断是否可以查到Selective 比如and条件取伦理积，OR个别来看


